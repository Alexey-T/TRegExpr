# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Andrey Sorokin
# This file is distributed under the same license as the TRegExpr package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Andrey Sorokin <filbert@yandex.ru>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TRegExpr 0.952\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-27 20:26+0300\n"
"PO-Revision-Date: 2019-04-27 17:26+0000\n"
"Last-Translator: Andrey Sorokin <filbert@yandex.ru>, 2019\n"
"Language-Team: Bulgarian (Bulgaria) (https://www.transifex.com/masterAndrey/teams/98461/bg_BG/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: bg_BG\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

# d6fc760c6fc94d9a899a479298b4c3dc
#: ../../faq.rst:2
msgid "Q. I found a terrible bug: TRegExpr raises Access Violation exception!"
msgstr ""
"Открих ужасна грешка: TRegExpr повдига изключението за нарушение на достъп!"

# f6b8fbc997e24100a1b2a07c99227929
# 1a6698bb92a3473fad6b6614a338d75a
# 2e2857f42d264fd1b12e80c2f091e503
# 2b0be10310a0472f9a5b65e914c0003a
# a93915915ecc4dc4881b760615872c18
# e1e41afc10534b61b37b14eb37204e60
# 6559a015535e493d9b8044357cec2710
# b4be4117777f4dc29c6ce4a3b2b526ea
# 26329b2210cc4905a1647818a69fd217
#: ../../faq.rst:5 ../../faq.rst:28 ../../faq.rst:43 ../../faq.rst:60
#: ../../faq.rst:79 ../../faq.rst:95 ../../faq.rst:116 ../../faq.rst:134
#: ../../faq.rst:155
msgid "A."
msgstr "А."

# 42f037ad3d0d4c54b07a7dca4f7e1779
#: ../../faq.rst:7
msgid ""
"You must create the object before usage. So, after You declared something "
"like:"
msgstr ""
"Трябва да създадете обекта преди употреба. Така че, след като ти обяви нещо "
"като:"

# e865298e59094744b6eb09fa43db311b
#: ../../faq.rst:14
msgid "do not forget to create the object instance:"
msgstr "не забравяйте да създадете екземпляр на обекта:"

# 781bb73b9cd34896bd61ea052d2869ea
#: ../../faq.rst:21
msgid "Q. How can I use TRegExpr with Borland C++ Builder?"
msgstr "В. Как мога да използвам TRegExpr с Borland C ++ Builder?"

# 252a4182e2ca41febf89678337efb6c2
#: ../../faq.rst:23
msgid "I have a problem since no header file (.h or .hpp) is available."
msgstr "Имам проблем, тъй като не е наличен заглавен файл (.h или .hpp)."

# c17bbf36186946eb9b60c1c609ec12ec
#: ../../faq.rst:30
msgid "Add RegExpr.pas to bcb project."
msgstr "Добавете RegExpr.pas към проекта bcb."

# 7b1b72640e2c46c7a5ae52e5dc598b7d
#: ../../faq.rst:31
msgid "Compile project. This generates the header file RegExpr.hpp."
msgstr "Съставете проект. Това генерира заглавния файл RegExpr.hpp."

# 16ee016a9fa547d7b412bd44ea526e44
#: ../../faq.rst:32
msgid "Now one can write code which uses the RegExpr unit."
msgstr "Сега човек може да пише код, който използва RegExpr единица."

# 92c071830b604493a9b0982e4c690f0d
#: ../../faq.rst:33
msgid "Don`t forget to add  #include “RegExpr.hpp” where needed."
msgstr "Не забравяйте да добавите #include “RegExpr.hpp” където е необходимо."

# a14b93d760474e5f83f70bb9479d161b
#: ../../faq.rst:34
msgid ""
"Don\\ ``t forget to replace all``\\\\\\ ``in regular expressions "
"with``\\\\\\\\` or redefined `EscChar <tregexpr_interface.html#escchar>`__ "
"const."
msgstr ""
"Не забравяйте да замените всички редовни изрази с `` или &#39;&#39; "
"предефинира &#39;`EscChar \\ t <tregexpr_interface.html#escchar> `__ const."

# 6c8450146f0841d1a013cff6b32e8dcc
#: ../../faq.rst:38
msgid ""
"Q. Why many r.e. (including r.e. from TRegExpr help and demo) work wrong in "
"Borland C++ Builder?"
msgstr ""
"Въпрос: Защо много от тях (включително от TRegExpr помощ и демо) работят "
"неправилно в Borland C ++ Builder?"

# 86691c4364694b7a8784006481ec491e
#: ../../faq.rst:45
msgid ""
"Please, reread answer to previous question ;) Symbol ``\\\\`` has special "
"treting in C++, so You have to ``escape`` it (as described in prev.answer). "
"But if You don\\ ``t like r.e. like``\\\\\\w+\\\\\\\\\\\\w+\\\\.\\\\w+\\ "
"``You can redefine constant EscChar (RegExpr.pas), for example "
"EscChar=``/``- then r.e. will be``/w+\\/w+/./w+`, sligtly unusual but more "
"readable.."
msgstr ""
"Моля, прочетете отговора на предишен въпрос;) Символ `` има специална "
"обработка в C ++, така че трябва да го `` избягате`` (както е описано в "
"prev.answer). Но ако не харесваш подобно на това, то w + \\ _ w + \\ _ w + "
"`` Можеш да предефинираш константата EscChar (RegExpr.pas), например EscChar"
" = `` / `` - след това отново ще бъде`` / w + / w + /. / w + `, леко "
"необичайно, но по-разбираемо .."

# 836b9a07a857496c8570a92e1ff86f73
#: ../../faq.rst:52
msgid "Q. Why does TRegExpr return more then one line?"
msgstr "Въпрос: Защо TRegExpr връща повече от един ред?"

# 27f1d5918d444c55b07292a55a65fd49
#: ../../faq.rst:54
msgid ""
"For example, r.e. ``<font .\\*>`` returns the first ``<font``, then the rest"
" of the file including last ``</html>``."
msgstr ""
"Например, `` <font .\\*>`` връща първото ``</font> <font``, then the rest of"
" the file including last ``</html> <font .\\*>``.</font>"

# 2456e655103c4b788ccb1bf90ed3772b
#: ../../faq.rst:62
msgid ""
"For backward compatibility, `modifier /s <regexp_syntax.html#modifier_s>`__ "
"is ``On`` by default."
msgstr ""
"За обратна съвместимост, `модификатор / и <regexp_syntax.html#modifier_s> "
"`__ е` `On`` по подразбиране."

# 74667df4efa94c54bb5fa7140be21392
#: ../../faq.rst:65
msgid ""
"Switch it Off and ``.`` will match any but `Line separators "
"<regexp_syntax.html#syntax_line_separators>`__ - as you wish."
msgstr ""
"Включете го и &quot;.&quot; Ще съвпадне с всички, но `Разделители на линии "
"<regexp_syntax.html#syntax_line_separators> `__ - както желаете."

# b31d50bb744f40ae9282e43a1967fad6
#: ../../faq.rst:68
msgid "BTW I suggest you ``<font (\\[^\\\\n>\\]\\*)>``, in Match[1] will be URL."
msgstr ""
"BTW Предлагам ви `` <font (\\[^\\\\n>]&gt; ``, в Match [1] ще бъде "
"URL.</font>"

# 65c336793c8746af86f7916910aa1bd4
#: ../../faq.rst:71
msgid "Q. Why does TRegExpr return more then I expect?"
msgstr "Въпрос: Защо TRegExpr се връща повече, отколкото очаквам?"

# d751c0f0d0e7458d905073d0ca772bee
#: ../../faq.rst:73
msgid ""
"For example r.e. ``<p>(.+)</p>`` applyed to string ``<p>a</p><p>b</p>`` "
"returns ``a</p><p>b`` but not ``a`` as I expected."
msgstr ""
"Например re `` <p> (. +) </p> `` приложен към низ `` <p> а </p><p> б </p> ``"
" връща `` a </p><p> b`` но не `` a``, както очаквах."

# 2e19907717ae4932b951c9e57b2bbd5a
#: ../../faq.rst:81
msgid ""
"By default all operators works in ``greedy`` mode, so they match as more as "
"it possible."
msgstr ""
"По подразбиране всички оператори работят в `` greedy`` режим, така че се "
"съчетават колкото се може повече."

# aff79b8422d0482f8c03a4f9e3e5c2f6
#: ../../faq.rst:84
msgid ""
"If You want ``non-greedy`` mode You can use ``non-greedy`` operators like "
"``+?`` and so on (new in v. 0.940) or switch all operators into ``non-"
"greedy`` mode with help of modifier ``g`` (use appropriate TRegExpr "
"properties or constractions like ``?(-g)`` in r.e.)."
msgstr ""
"Ако искате `` не жаден &#39;&#39; режим Можете да използвате `` не жадните``"
" оператори като `` +? `` И т.н. `mode с помощта на модификатор` `g`` "
"(използвайте подходящи свойства на TRegExpr или конструкции като` `? (- g)` "
"`в re)."

# 98b9a7d955c94ac699086ed6b50c59e2
#: ../../faq.rst:90
msgid "Q. How to parse sources like HTML with help of TRegExpr"
msgstr "Въпрос: Как да разберем източници като HTML с помощта на TRegExpr"

# 84b05a8a734c400f84412a496820942a
#: ../../faq.rst:97
msgid "Sorry folks, but it`s nearly impossible!"
msgstr "За съжаление, хора, но е почти невъзможно!"

# 8d6e67a8dc71482fab61baec80f05bb3
#: ../../faq.rst:99
msgid ""
"Of course, You can easily use TRegExpr for extracting some information from "
"HTML, as shown in my examples, but if You want accurate parsing You have to "
"use real parser, not r.e.!"
msgstr ""
"Разбира се, можете лесно да използвате TRegExpr за извличане на някаква "
"информация от HTML, както е показано в моите примери, но ако искате точен "
"парсинг, трябва да използвате истински парсер, а не!"

# ed36cb64ef9248de884cbb0c9a7d08f9
#: ../../faq.rst:103
msgid ""
"You can read full explanation in Tom Christiansen and Nathan Torkington "
"``Perl Cookbook``, for example. In short - there are many constractions that"
" can be easy parsed by real parser but cannot at all by r.e., and real "
"parser is MUCH faster do the parsing, because r.e. doesn`t simply scan input"
" stream, it performes optimization search that can take a lot of time."
msgstr ""
"Можете да прочетете пълното обяснение в Том Кристиансен и Нейтън Торкингтън "
"&quot;Perl Cookbook&quot;, например. Накратко - има много конструкции, които"
" могат лесно да бъдат анализирани от истинския анализатор, но въобще не "
"могат да бъдат рестартирани, а реалният анализатор е много по-бърз, тъй като"
" повторно не сканира входния поток, той извършва оптимизационно търсене, "
"което може да отнеме много време."

# ab01e6cbba074618b1022ffead0efc80
#: ../../faq.rst:111
msgid "Q. Is there a way to get multiple matchs of a pattern on TRegExpr?"
msgstr ""
"Въпрос: Има ли начин да се получат множество съвпадения на модел в TRegExpr?"

# fe91a4bc0fd4447489141747ee0ea224
#: ../../faq.rst:118
msgid "You can make loop and iterate match by match with ExecNext method."
msgstr ""
"Можете да създадете цикъл и да повторите съвпадение по съвпадение с метода "
"ExecNext."

# 65cf1d33d0854b8681d43b08b8f5d8c2
#: ../../faq.rst:120
msgid ""
"It cannot be done more easily becase of Dalphi isn\\ ``t interpretator as "
"Perl (and it``\\ s benefit - interpretators work very slow!)."
msgstr ""
"Тя не може да бъде направена по-лесно, ако Далфи не е тълкувател като Перл "
"(а ползата - тълкувателите работят много бавно!)."

# 641d4fc669be4c9aa475918aa91126ed
#: ../../faq.rst:124
msgid ""
"If You want some example, please take a look at TRegExpr.Replace method "
"implementation. or at the examples in `HyperLinksDecorator.pas "
"<#hyperlinksdecorator.html>`__"
msgstr ""
"Ако искате някакъв пример, моля вижте прилагането на метода "
"TRegExpr.Replace. или в примерите в `HyperLinksDecorator.pas &lt;# "
"hyperlinksdecorator.html&gt;` __"

# 9a455417a3d044c9b984ae73dcc64ace
#: ../../faq.rst:129
msgid ""
"Q. I am checking user input. Why does TRegExpr return ``True`` for wrong "
"input strings?"
msgstr ""
"Въпрос: Проверявам потребителските данни. Защо TRegExpr връща "
"&quot;True&quot; за погрешни низове?"

# 00eec936a2c44083b85cced632bd8d3e
#: ../../faq.rst:136
msgid ""
"In many cases TRegExpr users forget that regular expression is for SEARCH in"
" input string. So, if You want to make user to enter only 4 digits and using"
" for it ``\\\\d{4,4}`` expression, You can skip wrong user input like "
"``12345`` or ``any letters 1234 and anything else``. You have to add "
"checking for line start and line end to ensure there are not anything else "
"around: ``^\\\\d{4,4}$``."
msgstr ""
"В много случаи потребителите на TRegExpr забравят, че регулярният израз е за"
" SEARCH във входния низ. Така че, ако искате да накарате потребителя да "
"въведе само 4 цифри и да използвате за него `` {4,4} `` израз, можете да "
"пропуснете грешен потребителски вход като `` 12345`` или `` всякакви букви "
"1234 и нещо друго &quot;. Трябва да добавите проверка за стартиране на линия"
" и край на ред, за да сте сигурни, че няма нищо друго около: `` ^ {4,4} $ "
"``."

# 639d270d6ffc4a5a87c268c47189a924
#: ../../faq.rst:144
msgid "Q."
msgstr "Q."

# 3c901ebacebb4af69e073edc07332ecd
#: ../../faq.rst:146
msgid "Why does non-greedy iterators sometimes work as in greedy mode?"
msgstr "Защо понякога алчните итератори работят както в алчен режим?"

# 360da2fcf4f04302a1ec1b9557fad598
#: ../../faq.rst:148
msgid ""
"For example, the r.e. ``a+?,b+?`` applied to string ``aaa,bbb`` matches "
"``aaa,b``, but should it not match ``a,b`` because of non-greediness of "
"first iterator?"
msgstr ""
"Например, ре-`a + ?, b +?` `, Приложено към низа` `aaa, bbb``, съвпада с` "
"`aaa, b``, но ако не съвпада с` `a, b`` заради не-алчността на първия "
"итератор?"

# fc89dddf135b42ac956db2e8891af351
#: ../../faq.rst:157
msgid ""
"This is the limitation of used by TRegExpr (and Perl\\ ``s and many Unix``\\"
" s regular expressions) mathematics - r.e. performe only ``simple`` search "
"optimization, and do not try to do the best optimization. In some cases it\\"
" ``s bad, but in common it``\\ s rather advantage then limitation - because "
"of perfomance and predictability reasons."
msgstr ""
"Това е ограничението на използваните от TRegExpr (и регулярните изрази на "
"Perl и много от Unix) математика - изпълнява само &quot;проста&quot; "
"оптимизация на търсенето и не се опитва да направи най-добрата оптимизация. "
"В някои случаи това е &quot;лошо, но в общия случай&quot; е по-скоро "
"предимство, отколкото ограничение - поради съображения за производителност и"
" предсказуемост."

# fbd544ee50c042aaa8593e53d06b653a
#: ../../faq.rst:164
msgid ""
"The main rule - r.e. first of all try to match from current place and only "
"if it\\ ``s completely impossible move forward by one char and try again "
"from that place. So, if You use``\\ a,b+?\\ ``it match``\\ a,b\\ ``, but in "
"case of``\\ a+?,b+?\\ ``it``\\ s ``not recommended`` (due to non-greediness)"
" but possible to match more then one ``a``, so TRegExpr do it and at last "
"obtaines correct (but non optimum) match. TRegExpr like Perl\\ ``s or "
"Unix``\\ s r.e. doesn\\ ``t attempt to move forward and check - would it "
"be``\\ better\\ ``match. Moreover, it cannot be compared in terms``\\ more "
"or less good match\\` at all.."
msgstr ""
"Главното правило - преди всичко се опитвате да се съчетаете от текущото "
"място и само ако е напълно невъзможно да се движите напред с един символ и "
"опитайте отново от това място. Така че, ако използвате &#39;&#39; a, b +? "
"&#39;&#39; То съвпада&#39;`, a, b ``, но в случай на`` a + ?, b +? \\ T "
"препоръчва се &quot;(поради нежелателност), но е възможно да съвпадне повече"
" от едно&quot; а &quot;, така че TRegExpr го прави и най-накрая получава "
"правилно (но не оптимално) съвпадение. TRegExpr като Perl `s или Unix`` не "
"се опитва да се придвижи напред и да провери - дали ще бъде` `по-добро "
"съвпадение. Нещо повече, тя не може да бъде сравнена по отношение на повече "
"или по-малко добър мач."

# 4bb27a4712d645b1b26f8ab0240b9902
#: ../../faq.rst:173
msgid "Please, read `Syntax <regexp_syntax.html>`__ for more explanation."
msgstr ""
"Моля, прочетете `Синтаксис <regexp_syntax.html> `__ за повече обяснения."
