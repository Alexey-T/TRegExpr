# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Andrey Sorokin
# This file is distributed under the same license as the TRegExpr package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Andrey Sorokin <filbert@yandex.ru>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TRegExpr 0.952\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-27 20:26+0300\n"
"PO-Revision-Date: 2019-04-27 17:26+0000\n"
"Last-Translator: Andrey Sorokin <filbert@yandex.ru>, 2019\n"
"Language-Team: Russian (Russia) (https://www.transifex.com/masterAndrey/teams/98461/ru_RU/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru_RU\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n%100>=11 && n%100<=14)? 2 : 3);\n"

# d6fc760c6fc94d9a899a479298b4c3dc
#: ../../faq.rst:2
msgid "Q. I found a terrible bug: TRegExpr raises Access Violation exception!"
msgstr ""
"В. Я обнаружил ужасную ошибку: TRegExpr вызывает исключение Access "
"Violation!"

# f6b8fbc997e24100a1b2a07c99227929
# 1a6698bb92a3473fad6b6614a338d75a
# 2e2857f42d264fd1b12e80c2f091e503
# 2b0be10310a0472f9a5b65e914c0003a
# a93915915ecc4dc4881b760615872c18
# e1e41afc10534b61b37b14eb37204e60
# 6559a015535e493d9b8044357cec2710
# b4be4117777f4dc29c6ce4a3b2b526ea
# 26329b2210cc4905a1647818a69fd217
#: ../../faq.rst:5 ../../faq.rst:28 ../../faq.rst:43 ../../faq.rst:60
#: ../../faq.rst:79 ../../faq.rst:95 ../../faq.rst:116 ../../faq.rst:134
#: ../../faq.rst:155
msgid "A."
msgstr "A."

# 42f037ad3d0d4c54b07a7dca4f7e1779
#: ../../faq.rst:7
msgid ""
"You must create the object before usage. So, after You declared something "
"like:"
msgstr ""
"Вы должны создать объект перед использованием. Итак, после того, как Вы "
"заявили что-то вроде:"

# e865298e59094744b6eb09fa43db311b
#: ../../faq.rst:14
msgid "do not forget to create the object instance:"
msgstr "не забудьте создать экземпляр объекта:"

# 781bb73b9cd34896bd61ea052d2869ea
#: ../../faq.rst:21
msgid "Q. How can I use TRegExpr with Borland C++ Builder?"
msgstr "В. Как я могу использовать TRegExpr с Borland C ++ Builder?"

# 252a4182e2ca41febf89678337efb6c2
#: ../../faq.rst:23
msgid "I have a problem since no header file (.h or .hpp) is available."
msgstr "У меня проблема, так как нет файла заголовка (.h или .hpp)."

# c17bbf36186946eb9b60c1c609ec12ec
#: ../../faq.rst:30
msgid "Add RegExpr.pas to bcb project."
msgstr "Добавьте RegExpr.pas в проект bcb."

# 7b1b72640e2c46c7a5ae52e5dc598b7d
#: ../../faq.rst:31
msgid "Compile project. This generates the header file RegExpr.hpp."
msgstr "Скомпилировать проект. Это создает заголовочный файл RegExpr.hpp."

# 16ee016a9fa547d7b412bd44ea526e44
#: ../../faq.rst:32
msgid "Now one can write code which uses the RegExpr unit."
msgstr "Теперь можно написать код, который использует блок RegExpr."

# 92c071830b604493a9b0982e4c690f0d
#: ../../faq.rst:33
msgid "Don`t forget to add  #include “RegExpr.hpp” where needed."
msgstr "Не забудьте добавить #include «RegExpr.hpp», где это необходимо."

# a14b93d760474e5f83f70bb9479d161b
#: ../../faq.rst:34
msgid ""
"Don\\ ``t forget to replace all``\\\\\\ ``in regular expressions "
"with``\\\\\\\\` or redefined `EscChar <tregexpr_interface.html#escchar>`__ "
"const."
msgstr ""
"Не забывайте заменять все `` \\\\\\ `` в регулярных выражениях на `` "
"\\\\\\\\ `или переопределять` EscChar <tregexpr_interface.html#escchar> `__ "
"const."

# 6c8450146f0841d1a013cff6b32e8dcc
#: ../../faq.rst:38
msgid ""
"Q. Why many r.e. (including r.e. from TRegExpr help and demo) work wrong in "
"Borland C++ Builder?"
msgstr ""
"В. Почему многие из них (в том числе из справки и демонстрации TRegExpr) "
"работают неправильно в Borland C ++ Builder?"

# 86691c4364694b7a8784006481ec491e
#: ../../faq.rst:45
msgid ""
"Please, reread answer to previous question ;) Symbol ``\\\\`` has special "
"treting in C++, so You have to ``escape`` it (as described in prev.answer). "
"But if You don\\ ``t like r.e. like``\\\\\\w+\\\\\\\\\\\\w+\\\\.\\\\w+\\ "
"``You can redefine constant EscChar (RegExpr.pas), for example "
"EscChar=``/``- then r.e. will be``/w+\\/w+/./w+`, sligtly unusual but more "
"readable.."
msgstr ""
"Пожалуйста, перечитайте ответ на предыдущий вопрос;) Символ `` \\\\ `` имеет"
" специальный трейтинг в C ++, поэтому вы должны его `` экранировать`` (как "
"описано в prev.answer). Но если вам не нравится &#39;like&#39; `\\\\\\ w + "
"\\\\\\\\\\\\ w + \\\\. \\\\ w + \\` `Вы можете переопределить константу "
"EscChar (RegExpr.pas), например EscChar =` ` / `` - тогда re будет `` / w + "
"\\ / w + /. / w + `, немного необычно, но более читабельно .."

# 836b9a07a857496c8570a92e1ff86f73
#: ../../faq.rst:52
msgid "Q. Why does TRegExpr return more then one line?"
msgstr "В. Почему TRegExpr возвращает более одной строки?"

# 27f1d5918d444c55b07292a55a65fd49
#: ../../faq.rst:54
msgid ""
"For example, r.e. ``<font .\\*>`` returns the first ``<font``, then the rest"
" of the file including last ``</html>``."
msgstr ""
"Например, re `` <font .\\*>`` возвращает первый ``</font> <font``, then the "
"rest of the file including last ``</html> <font .\\*>``.</font>"

# 2456e655103c4b788ccb1bf90ed3772b
#: ../../faq.rst:62
msgid ""
"For backward compatibility, `modifier /s <regexp_syntax.html#modifier_s>`__ "
"is ``On`` by default."
msgstr ""
"Для обратной совместимости `модификатор / с <regexp_syntax.html#modifier_s> "
"`__ по умолчанию` `Вкл``."

# 74667df4efa94c54bb5fa7140be21392
#: ../../faq.rst:65
msgid ""
"Switch it Off and ``.`` will match any but `Line separators "
"<regexp_syntax.html#syntax_line_separators>`__ - as you wish."
msgstr ""
"Выключите его, и `` .`` будет соответствовать любому, кроме `Разделителей "
"строк <regexp_syntax.html#syntax_line_separators> `__ - как пожелаешь."

# b31d50bb744f40ae9282e43a1967fad6
#: ../../faq.rst:68
msgid "BTW I suggest you ``<font (\\[^\\\\n>\\]\\*)>``, in Match[1] will be URL."
msgstr ""
"Кстати, я предлагаю вам `` <font (\\[^\\\\n>\\] \\ *)&gt; ``, в Match [1] "
"будет URL.</font>"

# 65c336793c8746af86f7916910aa1bd4
#: ../../faq.rst:71
msgid "Q. Why does TRegExpr return more then I expect?"
msgstr "В. Почему TRegExpr возвращает больше, чем я ожидаю?"

# d751c0f0d0e7458d905073d0ca772bee
#: ../../faq.rst:73
msgid ""
"For example r.e. ``<p>(.+)</p>`` applyed to string ``<p>a</p><p>b</p>`` "
"returns ``a</p><p>b`` but not ``a`` as I expected."
msgstr ""
"Например &#39;`` <p> (. +) </p> `` применяется к строке `` <p> </p><p> б "
"</p> `` возвращает `` a </p><p> b`` но не `` a``, как я ожидал."

# 2e19907717ae4932b951c9e57b2bbd5a
#: ../../faq.rst:81
msgid ""
"By default all operators works in ``greedy`` mode, so they match as more as "
"it possible."
msgstr ""
"По умолчанию все операторы работают в `` жадном`` режиме, поэтому они "
"совпадают как можно больше."

# aff79b8422d0482f8c03a4f9e3e5c2f6
#: ../../faq.rst:84
msgid ""
"If You want ``non-greedy`` mode You can use ``non-greedy`` operators like "
"``+?`` and so on (new in v. 0.940) or switch all operators into ``non-"
"greedy`` mode with help of modifier ``g`` (use appropriate TRegExpr "
"properties or constractions like ``?(-g)`` in r.e.)."
msgstr ""
"Если вы хотите режим `` non-greedy``, вы можете использовать операторы `` "
"non-greedy``, такие как `` +? `` И т. Д. (Новое в v. 0.940), или переключить"
" все операторы в `` non-greedy` `режим с помощью модификатора` `g`` "
"(используйте соответствующие свойства или ограничения TRegExpr, такие как` "
"`? (- g)` `в re)."

# 98b9a7d955c94ac699086ed6b50c59e2
#: ../../faq.rst:90
msgid "Q. How to parse sources like HTML with help of TRegExpr"
msgstr "В. Как анализировать источники, такие как HTML, с помощью TRegExpr"

# 84b05a8a734c400f84412a496820942a
#: ../../faq.rst:97
msgid "Sorry folks, but it`s nearly impossible!"
msgstr "Извините, ребята, но это почти невозможно!"

# 8d6e67a8dc71482fab61baec80f05bb3
#: ../../faq.rst:99
msgid ""
"Of course, You can easily use TRegExpr for extracting some information from "
"HTML, as shown in my examples, but if You want accurate parsing You have to "
"use real parser, not r.e.!"
msgstr ""
"Конечно, вы можете легко использовать TRegExpr для извлечения некоторой "
"информации из HTML, как показано в моих примерах, но если вы хотите точного "
"разбора, вы должны использовать настоящий парсер, а не re!"

# ed36cb64ef9248de884cbb0c9a7d08f9
#: ../../faq.rst:103
msgid ""
"You can read full explanation in Tom Christiansen and Nathan Torkington "
"``Perl Cookbook``, for example. In short - there are many constractions that"
" can be easy parsed by real parser but cannot at all by r.e., and real "
"parser is MUCH faster do the parsing, because r.e. doesn`t simply scan input"
" stream, it performes optimization search that can take a lot of time."
msgstr ""
"Вы можете прочитать полное объяснение в Том Кристиансен и Натан Торкингтон "
"`` Perl Cookbook``, например. Вкратце - есть много ограничений, которые "
"могут быть легко проанализированы реальным парсером, но не могут быть "
"проанализированы ре, и реальный парсер НАМНОГО быстрее выполняет "
"синтаксический анализ, потому что он не просто сканирует входной поток, он "
"выполняет оптимизационный поиск, который может занять много времени."

# ab01e6cbba074618b1022ffead0efc80
#: ../../faq.rst:111
msgid "Q. Is there a way to get multiple matchs of a pattern on TRegExpr?"
msgstr "В. Есть ли способ получить несколько совпадений шаблона на TRegExpr?"

# fe91a4bc0fd4447489141747ee0ea224
#: ../../faq.rst:118
msgid "You can make loop and iterate match by match with ExecNext method."
msgstr ""
"Вы можете сделать цикл и повторить совпадение с помощью метода ExecNext."

# 65cf1d33d0854b8681d43b08b8f5d8c2
#: ../../faq.rst:120
msgid ""
"It cannot be done more easily becase of Dalphi isn\\ ``t interpretator as "
"Perl (and it``\\ s benefit - interpretators work very slow!)."
msgstr ""
"Это не может быть сделано проще, потому что Дальфи не интерпретирует как "
"Perl (и это выгодно - интерпретаторы работают очень медленно!)."

# 641d4fc669be4c9aa475918aa91126ed
#: ../../faq.rst:124
msgid ""
"If You want some example, please take a look at TRegExpr.Replace method "
"implementation. or at the examples in `HyperLinksDecorator.pas "
"<#hyperlinksdecorator.html>`__"
msgstr ""
"Если вам нужен пример, посмотрите на реализацию метода TRegExpr.Replace. или"
" в примерах в `HyperLinksDecorator.pas &lt;# hyperlinksdecorator.html&gt;` "
"__"

# 9a455417a3d044c9b984ae73dcc64ace
#: ../../faq.rst:129
msgid ""
"Q. I am checking user input. Why does TRegExpr return ``True`` for wrong "
"input strings?"
msgstr ""
"В. Я проверяю пользовательский ввод. Почему TRegExpr возвращает `` True`` "
"для неверных строк ввода?"

# 00eec936a2c44083b85cced632bd8d3e
#: ../../faq.rst:136
msgid ""
"In many cases TRegExpr users forget that regular expression is for SEARCH in"
" input string. So, if You want to make user to enter only 4 digits and using"
" for it ``\\\\d{4,4}`` expression, You can skip wrong user input like "
"``12345`` or ``any letters 1234 and anything else``. You have to add "
"checking for line start and line end to ensure there are not anything else "
"around: ``^\\\\d{4,4}$``."
msgstr ""
"Во многих случаях пользователи TRegExpr забывают, что регулярное выражение "
"для ПОИСКА во входной строке. Итак, если вы хотите, чтобы пользователь "
"вводил только 4 цифры и использовал для него `` \\\\ d {4,4} `` выражение, "
"вы можете пропустить неправильный ввод пользователя, например `` 12345`` или"
" `` любые буквы 1234 и что-нибудь еще``. Вы должны добавить проверку начала "
"и конца строки, чтобы убедиться, что вокруг ничего нет: `` ^ \\\\ d {4,4} $ "
"``."

# 639d270d6ffc4a5a87c268c47189a924
#: ../../faq.rst:144
msgid "Q."
msgstr "Q."

# 3c901ebacebb4af69e073edc07332ecd
#: ../../faq.rst:146
msgid "Why does non-greedy iterators sometimes work as in greedy mode?"
msgstr "Почему не жадные итераторы иногда работают как в жадном режиме?"

# 360da2fcf4f04302a1ec1b9557fad598
#: ../../faq.rst:148
msgid ""
"For example, the r.e. ``a+?,b+?`` applied to string ``aaa,bbb`` matches "
"``aaa,b``, but should it not match ``a,b`` because of non-greediness of "
"first iterator?"
msgstr ""
"Например, re `` a + ?, b +? ``, Примененное к строке `` aaa, bbb``, "
"соответствует `` aaa, b``, но не должно совпадать с `` a, b`` из-за жадности"
" первого итератора?"

# fc89dddf135b42ac956db2e8891af351
#: ../../faq.rst:157
msgid ""
"This is the limitation of used by TRegExpr (and Perl\\ ``s and many Unix``\\"
" s regular expressions) mathematics - r.e. performe only ``simple`` search "
"optimization, and do not try to do the best optimization. In some cases it\\"
" ``s bad, but in common it``\\ s rather advantage then limitation - because "
"of perfomance and predictability reasons."
msgstr ""
"Это ограничение используемой математической математики TRegExpr (и "
"регулярных выражений Perl и многих Unix) - они выполняют только `` простую``"
" поисковую оптимизацию и не пытаются выполнять лучшую оптимизацию. В "
"некоторых случаях это плохо, но в целом это скорее преимущество, чем "
"ограничение - по причинам производительности и предсказуемости."

# fbd544ee50c042aaa8593e53d06b653a
#: ../../faq.rst:164
msgid ""
"The main rule - r.e. first of all try to match from current place and only "
"if it\\ ``s completely impossible move forward by one char and try again "
"from that place. So, if You use``\\ a,b+?\\ ``it match``\\ a,b\\ ``, but in "
"case of``\\ a+?,b+?\\ ``it``\\ s ``not recommended`` (due to non-greediness)"
" but possible to match more then one ``a``, so TRegExpr do it and at last "
"obtaines correct (but non optimum) match. TRegExpr like Perl\\ ``s or "
"Unix``\\ s r.e. doesn\\ ``t attempt to move forward and check - would it "
"be``\\ better\\ ``match. Moreover, it cannot be compared in terms``\\ more "
"or less good match\\` at all.."
msgstr ""
"Основное правило - сначала пытайтесь сопоставить с текущего места и только в"
" том случае, если совершенно невозможно продвинуться вперед на один символ и"
" повторить попытку с этого места. Итак, если Вы используете `` \\ a, b +? \\"
" `` Оно совпадает`` \\ a, b \\ ``, но в случае `` \\ a + ?, b +? \\ `` It`` "
"\\ s `` not рекомендуется `` (из-за не жадности), но возможно сопоставить "
"более одного `` a``, поэтому TRegExpr сделает это и, наконец, получит "
"правильное (но не оптимальное) совпадение. TRegExpr, такой как Perl, `` s "
"или Unix``, не пытается продвинуться вперед и проверить - будет ли `` \\ "
"лучше \\ &quot;` соответствовать. Более того, его нельзя сравнивать с точки "
"зрения `` \\ более-менее хорошего соответствия \\ `&quot; вообще .."

# 4bb27a4712d645b1b26f8ab0240b9902
#: ../../faq.rst:173
msgid "Please, read `Syntax <regexp_syntax.html>`__ for more explanation."
msgstr ""
"Пожалуйста, прочитайте `Синтаксис <regexp_syntax.html> `__ для большего "
"объяснения."
