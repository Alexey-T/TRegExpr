# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Andrey Sorokin
# This file is distributed under the same license as the TRegExpr package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Andrey Sorokin <filbert@yandex.ru>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TRegExpr 0.952\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-04 06:10+0300\n"
"PO-Revision-Date: 2019-05-04 03:10+0000\n"
"Last-Translator: Andrey Sorokin <filbert@yandex.ru>, 2019\n"
"Language-Team: Russian (https://www.transifex.com/masterAndrey/teams/98461/ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n%100>=11 && n%100<=14)? 2 : 3);\n"

# cf1fdea7e27f4b6b9e33211b59fc1c64
#: ../../faq.rst:2
msgid "FAQ"
msgstr "Часто задаваемые вопросы"

# d6fc760c6fc94d9a899a479298b4c3dc
#: ../../faq.rst:5
msgid "I found a terrible bug: TRegExpr raises Access Violation exception!"
msgstr ""
"Я обнаружил ужасную ошибку: TRegExpr вызывает исключение Access Violation!"

# 40da4f3424204e0f9f5560fb3c87b10a
# 3833e9a61eba4b809278c359680e17ca
# 5a47e00001fb4510bd56b96c8ae2de48
# 063d88b9d1924eb3833098263231246a
# ac33582fb29a41d182d1d5a37f804714
# 7943cbe2de2f4a578f118eb36182d84c
# e2ff87750895422bbacd133047904d32
# 736edb290b65410a8c8b1774a344c60d
# 4de8457af7c741fea504b9c213198f59
#: ../../faq.rst:7 ../../faq.rst:27 ../../faq.rst:39 ../../faq.rst:55
#: ../../faq.rst:71 ../../faq.rst:84 ../../faq.rst:104 ../../faq.rst:115
#: ../../faq.rst:135
msgid "**Answer**"
msgstr "**Ответ**"

# 42f037ad3d0d4c54b07a7dca4f7e1779
#: ../../faq.rst:9
msgid ""
"You must create the object before usage. So, after you declared something "
"like:"
msgstr ""
"Вы должны создать объект перед использованием. Итак, после того, как вы "
"объявили что-то вроде:"

# e865298e59094744b6eb09fa43db311b
#: ../../faq.rst:16
msgid "do not forget to create the object instance:"
msgstr "не забудьте создать экземпляр объекта:"

# 781bb73b9cd34896bd61ea052d2869ea
#: ../../faq.rst:23
msgid "How can I use TRegExpr with Borland C++ Builder?"
msgstr "Как использовать TRegExpr с Borland C ++ Builder?"

# 252a4182e2ca41febf89678337efb6c2
#: ../../faq.rst:25
msgid ""
"I have a problem since no header file (``.h`` or ``.hpp``) is available."
msgstr "У меня проблема, нет файла заголовка (``.h`` или ``.hpp``)."

# c17bbf36186946eb9b60c1c609ec12ec
#: ../../faq.rst:29
msgid "Add ``RegExpr.pas`` to ``bcb`` project."
msgstr "Добавьте ``RegExpr.pas`` к проекту ``bcb``."

# 7b1b72640e2c46c7a5ae52e5dc598b7d
#: ../../faq.rst:30
msgid "Compile project. This generates the header file ``RegExpr.hpp``."
msgstr "Скомпилировать проект. Это создает заголовочный файл ``RegExpr.hpp``."

# 16ee016a9fa547d7b412bd44ea526e44
#: ../../faq.rst:31
msgid "Now you can write code which uses the ``RegExpr`` unit."
msgstr "Теперь вы можете писать код, использующий модуль ``RegExpr``."

# 92c071830b604493a9b0982e4c690f0d
#: ../../faq.rst:32
msgid "Don't forget to add  ``#include “RegExpr.hpp”`` where needed."
msgstr ""
"Не забудьте добавить ``#include “RegExpr.hpp”`` там, где это необходимо."

# a14b93d760474e5f83f70bb9479d161b
#: ../../faq.rst:33
msgid ""
"Don't forget to replace all ``\\`` in regular expressions with ``\\\\`` or "
"redefined `EscChar <tregexpr.html#escchar>`__ const."
msgstr ""
"Не забудьте заменить все ``\\`` в регулярных выражениях на ``\\`` или "
"переопределить `EscChar <tregexpr.html#escchar>`_ const."

# 6c8450146f0841d1a013cff6b32e8dcc
#: ../../faq.rst:37
msgid ""
"Why many r.e. (including r.e. from TRegExpr help and demo) work wrong in "
"Borland C++ Builder?"
msgstr ""
"Почему многие примеры (включая примеры из документации) работают неправильно"
" в Borland C ++ Builder?"

# 86691c4364694b7a8784006481ec491e
#: ../../faq.rst:41
msgid ""
"The hint is in the previous question ;) Symbol ``\\`` has special meaning in"
" ``C++``, so you have to ``escape`` it (as described in previous answer). "
"But if you don't like r.e. like ``\\\\w+\\\\\\\\w+\\\\.\\\\w+`` you can "
"redefine the constant ``EscChar`` (in ``RegExpr.pas``). For example "
"``EscChar = \"/\"``. Then you can write ``/w+/w+/./w+``, looks unusual but "
"more readable."
msgstr ""
"Подсказка есть в предыдущем вопросе;) Символ ``\\`` имеет особое значение в "
"``C ++``, поэтому вы должны ``эскейпить`` его (как описано в предыдущем "
"ответе). Но если вам не нравится, как выглядит ``\\w+\\\\w+\\.\\w+``, вы "
"можете переопределить константу ``EscChar`` (в ``RegExpr.pas``). Скажем, "
"``EscChar = \"/\"``. Затем вы можете написать ``/w+/w+/. /W+`` - выглядит "
"необычно, но более читабельно."

# 836b9a07a857496c8570a92e1ff86f73
#: ../../faq.rst:50
msgid "Why does TRegExpr return more then one line?"
msgstr "Почему TRegExpr возвращает более одной строки?"

# 27f1d5918d444c55b07292a55a65fd49
#: ../../faq.rst:52
msgid ""
"For example, r.e. ``<font .\\*>`` returns the first ``<font``, then the rest"
" of the file including last ``</html>``."
msgstr ""
"Например, регулярное выражение ``<font .\\*>`` возвращает первый же "
"``<font``, далее весь последующий текст до финального``</html>``."

# 2456e655103c4b788ccb1bf90ed3772b
#: ../../faq.rst:57
msgid ""
"For backward compatibility, `modifier /s "
"<regular_expressions.html#modifier_s>`__ is ``On`` by default."
msgstr ""
"Для обратной совместимости `модификатор /s "
"<regular_expressions.html#modifier_s>`_ по умолчанию ``Вкл``."

# 74667df4efa94c54bb5fa7140be21392
#: ../../faq.rst:60
msgid ""
"Switch it Off and ``.`` will match any but `Line separators "
"<regular_expressions.html#syntax_line_separators>`__ - exactly as you wish."
msgstr ""
"Выключите его, и ``.`` будет соответствовать любому символу, кроме "
"`Разделителей строк <regular_expressions.html#syntax_line_separators>`_ - "
"именно так, как вы хотите."

# b31d50bb744f40ae9282e43a1967fad6
#: ../../faq.rst:63
msgid "BTW I suggest ``<font ([^\\n>]*)>``, in ``Match[1]`` will be the URL."
msgstr ""
"Я лично предлагаю ``<font ([^\\n>] *)>``, тогда в ``Match [1]`` будет URL."

# 65c336793c8746af86f7916910aa1bd4
#: ../../faq.rst:66
msgid "Why does TRegExpr return more then I expect?"
msgstr "Почему TRegExpr возвращает больше, чем я ожидаю?"

# d751c0f0d0e7458d905073d0ca772bee
#: ../../faq.rst:68
msgid ""
"For example r.e. ``<p>(.+)</p>`` applyed to string ``<p>a</p><p>b</p>`` "
"returns ``a</p><p>b`` but not ``a`` as I expected."
msgstr ""
"Например ``<p> (. +) </p>`` для строки ``<p>a </p><p> b </p>`` возвращает "
"``a </p><p> b`` но не ``a``, как ожидается."

# 2e19907717ae4932b951c9e57b2bbd5a
#: ../../faq.rst:73
msgid ""
"By default all operators works in ``greedy`` mode, so they match as more as "
"it possible."
msgstr ""
"По умолчанию все операторы работают в ``жадном`` режиме, поэтому они "
"совпадают как можно больше."

# aff79b8422d0482f8c03a4f9e3e5c2f6
#: ../../faq.rst:76
msgid ""
"If you want ``non-greedy`` mode you can use ``non-greedy`` operators like "
"``+?`` and so on or switch all operators into ``non-greedy`` mode with help "
"of modifier ``g`` (use appropriate TRegExpr properties or operator ``?(-g)``"
" in r.e.)."
msgstr ""
"Если вам нужен режим ``не жадный режим``, вы можете использовать ``не "
"жадные`` варианты операторов, такие как ``+? `` и т. д., или переключить все"
" операторы в ``не жадный`` режим с помощью модификатора ``g`` (используйте "
"соответствующие свойства TRegExpr или оператор ``?(-g)`` внутри выражения)."

# 98b9a7d955c94ac699086ed6b50c59e2
#: ../../faq.rst:82
msgid "How to parse sources like HTML with help of TRegExpr"
msgstr "Как анализировать HTML, с помощью TRegExpr"

# 84b05a8a734c400f84412a496820942a
#: ../../faq.rst:86
msgid "Sorry folks, but it's nearly impossible!"
msgstr "Извините, ребята, но это почти невозможно!"

# 8d6e67a8dc71482fab61baec80f05bb3
#: ../../faq.rst:88
msgid ""
"Of course, you can easily use TRegExpr for extracting some information from "
"HTML, as shown in my examples, but if you want accurate parsing you have to "
"use real parser, not r.e."
msgstr ""
"Конечно, вы можете легко использовать TRegExpr для извлечения некоторой "
"информации из HTML, как показано в моих примерах, но если вам нужен точный "
"синтаксический анализ, вы должны использовать полноценный парсер, а не"

# 6c0a493a04494f7aae37970898a379f4
#: ../../faq.rst:92
msgid ""
"You can read full explanation in Tom Christiansen and Nathan Torkington "
"``Perl Cookbook``, for example."
msgstr ""
"Вы можете прочитать полное объяснение в Том Кристиансен и Натан Торкингтон "
"``Perl Cookbook``, например."

# ed36cb64ef9248de884cbb0c9a7d08f9
#: ../../faq.rst:95
msgid ""
"In short - there are many structures that can be easy parsed by real parser "
"but cannot at all by r.e., and real parser is much faster to do the parsing,"
" because r.e. doesn't simply scan input stream, it performs optimization "
"search that can take a lot of time."
msgstr ""
"Вкратце - есть много структур, которые могут быть легко проанализированы "
"реальным парсером, но не могут быть проанализированы регулярными "
"выражениями. Полноценный парсер намного быстрее выполнит синтаксический "
"анализ."

# ab01e6cbba074618b1022ffead0efc80
#: ../../faq.rst:102
msgid "Is there a way to get multiple matches of a pattern on TRegExpr?"
msgstr "Есть ли способ получить несколько совпадений шаблона на TRegExpr?"

# fe91a4bc0fd4447489141747ee0ea224
#: ../../faq.rst:106
msgid "You can iterate matches with ExecNext method."
msgstr "Вы искать последующие совпадения с помощью метода ExecNext."

# 641d4fc669be4c9aa475918aa91126ed
#: ../../faq.rst:108
msgid ""
"If you want some example, please take a look at ``TRegExpr.Replace`` method "
"implementation or at the examples for `HyperLinksDecorator <demos.html>`_"
msgstr ""
"Если вам нужен какой-то пример, посмотрите на реализацию метода "
"``TRegExpr.Replace`` или на примеры для `HyperLinksDecorator <demos.html>`_"

# 9a455417a3d044c9b984ae73dcc64ace
#: ../../faq.rst:113
msgid ""
"I am checking user input. Why does TRegExpr return ``True`` for wrong input "
"strings?"
msgstr ""
"Я проверяю пользовательский ввод. Почему TRegExpr возвращает ``True`` для "
"неправильных входных строк?"

# e7dd38f412234006aefa108dc8555b35
#: ../../faq.rst:117
msgid ""
"In many cases TRegExpr users forget that regular expression is for "
"**search** in input string."
msgstr ""
"Во многих случаях пользователи TRegExpr забывают, что регулярное выражение "
"предназначено для **поиска** во входной строке."

# 84c50dddfedc418ca4e5de33a2388527
#: ../../faq.rst:120
msgid ""
"So, for example if you use ``\\d{4,4}`` expression, you will get success for"
" wrong user inputs like ``12345`` or ``any letters 1234``."
msgstr ""
"Так, например,  выражение ``\\d{4,4}`` совпадет и с ``12345`` и с ``любые "
"буквы 1234``."

# 555ace2776ff491baccc6bc35a2574b3
#: ../../faq.rst:123
msgid ""
"You have to check from line start to line end to ensure there are no "
"anything else around: ``^\\d{4,4}$``."
msgstr ""
"Вы должны проверить от начала строки до конца строки, чтобы убедиться, что "
"вокруг ничего больше нет: ``^\\d{4,4}$``."

# 3c901ebacebb4af69e073edc07332ecd
#: ../../faq.rst:129
msgid "Why does non-greedy iterators sometimes work as in greedy mode?"
msgstr "Почему не жадные итераторы иногда работают в жадном режиме?"

# 360da2fcf4f04302a1ec1b9557fad598
#: ../../faq.rst:131
msgid ""
"For example, the r.e. ``a+?,b+?`` applied to string ``aaa,bbb`` matches "
"``aaa,b``, but should it not match ``a,b`` because of non-greediness of "
"first iterator?"
msgstr ""
"Например, re ``a+?,b+? ``, для строки ``aaa, bbb``, найдет ``aaa,b``, но не "
"``a,b`` хотя первый итератор не жаден?"

# fc89dddf135b42ac956db2e8891af351
#: ../../faq.rst:137
msgid ""
"This is because of TRegExpr way to work. In fact many others r.e. engines "
"work exactly the same: they performe only ``simple`` search optimization, "
"and do not try to do the best optimization."
msgstr ""
"Регулярные выражения только ищут первое же совпадение и не пытаются найти "
"\"наилучшее\" совпадение."

# ef8b9a54e25e4fa9a9ae7ab5904a4b17
#: ../../faq.rst:141
msgid ""
"In some cases it's bad, but in common it's rather advantage then limitation,"
" because of performance and predictability reasons."
msgstr ""
"В некоторых случаях это плохо, но в целом это скорее преимущество, чем "
"ограничение, по причинам производительности и предсказуемости."

# 947ff8c1afe940479c8fd0c41677ae41
#: ../../faq.rst:144
msgid ""
"The main rule - r.e. first of all try to match from current place and only "
"if that's completely impossible move forward by one char and try again from "
"next position in the text."
msgstr ""
"Основное правило - сначала пытаемся найти соотвествие, начиная с текущей "
"позиции в строке и, только если это невозможно, продвигаемся на один символ "
"вперед и попробуем снова со следующей позиции в тексте."

# 7c46172a4c3b4941b63c368dc1b2a948
#: ../../faq.rst:148
msgid ""
"So, if you use ``a,b+?`` it'll match ``a,b``. In case of ``a+?,b+?`` it's "
"now not recommended (we add non-greedy modifyer) but still possible to match"
" more then one ``a``, so TRegExpr will do it."
msgstr ""
"Если вы используете ``a,b+?`` то это будет соответствовать ``a,b``. В случае"
" ``a+?,b+?``, не смотря на не жадный модификатор, все же возможно захватить "
"более одного ``a``, поэтому TRegExpr сделает это."

# 41feed27e8ad405faa9ea1e4b0c8d18f
#: ../../faq.rst:152
msgid ""
"TRegExpr like Perl's or Unix's r.e. doesn't attempt to move forward and "
"check - would it will be \"better\" match. Fisrt of all, just because there "
"is no way to say it's more or less good match."
msgstr ""
"Регулярные выражения, не пытаются двигаться дальше по тексту и проверять - "
"удастся ли найти \"лучшее\" совпадение. Хотя бы потому, что нельзя сказать, "
"что такое \"лучше\"."
